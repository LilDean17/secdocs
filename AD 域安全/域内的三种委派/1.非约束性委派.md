# 域内的三种委派方式

域委派：使得上游服务能使用用户凭据访问下游服务，使得下游服务根据域用户判断权限，例如：

**web 用户 hack**---------------访问------------------> **web 服务器**（ www-data 域服务账户运行）-------------------访问（以 hack 用户的身份）----------------------> **数据库服务器**（ SQLServiceAccount 服务账户运行）

当 hack 用户访问 web 服务器时，在 web 服务器上运行代码的用户是域用户 www-data ，而执行 web 后端代码操作的是 hack 用户， www-data 属于系统层，hack 属于应用层。当 web 服务器使用委派访问数据库服务器时，数据库服务器运行代码的用户是域用户 SQLServiceAccount ，而执行查询操作的用户是 hack 用户，SQLServiceAccount 属于系统层，hack 属于应用层。

当 web 服务器访问数据库时，并没有以 www-data 域内服务账户访问数据库服务器，而是通过委派利用 hack 用户的身份进行访问。上游服务：委派用户凭据的服务。下游服务：被上游服务访问的服务。

只有注册了 spn 的账户（服务账户或机器账户）才有可能用于委派，因为 spn 能将域用户映射到域服务。

### 3种委派

- 非约束性委派（UD：Unconstrained Delegation）
- 约束性委派（CD：Constrained Delegation）
- 基于资源的约束性委派（RBCD：Resource Based Constrained Delegation）

### 非约束性委派（UD）

上游服务账户能够获取用户的 tgt 认购权证，并将 tgt 缓存到 lass 进程，使得上游服务账户能利用用户的 tgt 认购权证，以用户的权限访问其他服务。

注，非约束性委派的特点：

- 非约束性委派设计时，没有对上游服务账户获取用户的 tgt 进行限制，使得服务账户能使用用户的 tgt 请求到任何服务的 st ，这使得服务账户使用用户凭据访问任何服务。
- 非约束性委派的配置需要 SeEnableDelegationPrivilege 特权，域管理员和企业管理员默认有这个特权。
- 非约束性委派配置在上游服务账户上，不会被下游服务所约束。
- 配置了非约束性委派的机器账户的 userAccountControl 属性：WORKSTATION_TRUST_ACCOUNT | TRUSTED_FOR_DELEGATION，对应16进制0x81000 。
- 配置了非约束性委派的服务账户的 userAccountControl 属性：NORMAL_ACCOUNT | TRUSTED_FOR_DELEGATION，对应16进制0x80200 。
- 域控默认配置了非约束性委派，也有 TRUSTED_FOR_DELEGATION 标志位。

##### 非约束性委派流程

![image-20241005185440188](https://cdn.jsdelivr.net/gh/LilDean17/secdoc@main/AD%20%E5%9F%9F%E5%AE%89%E5%85%A8/%E5%9F%9F%E5%86%85%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%94%E6%B4%BE/images/image-20241005185440188.png)

1. 用户发送 as-req 请求**上游服务1**。

2. kdc 发送 as-rep 返回 **tgt1 认购权证**。

3. 用户发送 tgs-req 请求**下游服务2**。

4. kdc 发送 tgs-rep 返回可转发的 **tgt2 认购权证**。

   总结前4步：用户请求两个 tgt ， tgt1 要用来请求**上游服务1**的 st ，另一个 tgt2 是用来发给**上游服务1**的可转发的 tgt ，**上游服务1**有了这个可转发的 tgt2 ，他将能够代表此用户访问其他服务。

5. 用户利用 **tgt1** 向 kdc 发送 tgs-req 请求**上游服务1的 st 服务票据**。

6. kdc 发送 tgs-rep 返回**上游服务1的 st 服务票据**给用户。

7. 用户使用 st 发送 ap-req 请求上游服务1，同时发送了 tgt1 和可转发的 tgt2，以及 tgt2的 Session Key。

   - tgt1 的作用就是普通的 Kerberos 身份验证请求。
   - tgt2 是可转发的，它的作用就是发送给上游服务，供其使用。

   注：上游服务想要使用 tgt2 来代表用户访问其他服务，就需要获得 tgt2 内的 Session Key （因为 tgs-req 需要 Session Key 加密时间戳作为身份验证），所以上游服务获得 Session Key 需要通过用户接受到 tgt2 的 as-rep 请求包后，使用客户密码 hash 解密 Logon Session Key 后，将 Session Key 发送到上游服务。

8. **上游服务1**的服务账户利用**可转发的 tgt2**请求**下游服务2的 st**，以代表客户访问服务。

9. kdc 返回 **下游服务2的 st**给 **上游服务1**。

   此时服务1的服务账户拿到了服务2的 st 服务票据，就可以访问服务2了

10. 服务1的服务账户发送 ap-req 请求服务2。

11. 服务2验证 ap-req ，并响应结果给服务1。

12. 服务1的服务账户有了响应结果后，处理转发给用户。

总结：用户直接将自己请求到的 tgt 认购权证发给上游服务1服务账户供它使用，代表用户对上游服务1的充分信任，上游服务1有权利使用用户凭据进行任何操作。

漏洞：

非约束性委派配置在上游服务账户上，不会被下游服务所约束。这使得上游服务进行委派时， kdc 只会判断上游服务有没有配置委派。此时如果上游服务的凭据被攻击者拿到，那么攻击者利用此上游服务获得到在此服务上配置委派的用户的凭据。

##### 非约束性委派的配置

域控默认配置了非约束性委派，非约束性委派的配置对应如下图的 “信任此 计算机/用户 来委派任何服务” 选项：

![image-20241226150704602](https://cdn.jsdelivr.net/gh/LilDean17/secdoc@main/AD%20%E5%9F%9F%E5%AE%89%E5%85%A8/%E5%9F%9F%E5%86%85%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%94%E6%B4%BE/images/image-20241226150704602.png)

当我们对某个用户添加此选项后，此用户拥有了非约束性委派权限。

